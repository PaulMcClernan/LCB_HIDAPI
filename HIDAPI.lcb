library community.livecode.paulmcclernan.hidapi

metadata version is "0.1"
metadata author is "Paul McClernan"
metadata title is "LC HID API"

use com.livecode.foreign
use com.livecode.canvas
use com.livecode.string
use com.livecode.char
use com.livecode.array
use com.livecode.list
use com.livecode.widget
use com.livecode.engine
use com.livecode.library.widgetutils
use com.livecode.system
use com.livecode.byte
use com.livecode.date
use com.livecode.binary
use com.livecode.bitwise
use com.livecode.math

-- MCStringEncodings
-- The (7-bit) ASCII encoding.
constant kMCStringEncodingASCII is 0
-- The standard Windows (Latin-1) encoding.
constant	kMCStringEncodingWindows1252 is 1
-- The standard Mac (Latin-1) encoding.
constant	kMCStringEncodingMacRoman is 2
-- The standard Linux (Latin-1) encoding.
constant kMCStringEncodingISO8859_1 is 3
-- The UTF-8 string encoding.  In LiveCode, this permits overlong sequences when decoding, but does not generate them when encoding.
constant kMCStringEncodingUTF8 is 4
-- The UTF-16 string encoding in little endian byte-order.
constant	kMCStringEncodingUTF16LE is 5
-- The UTF-16 string encoding in big endian byte-order.
constant kMCStringEncodingUTF16BE is 6
-- The UTF-32 string encoding in little endian byte-order.
constant kMCStringEncodingUTF32LE is 7
-- The UTF-32 string encoding in big endian byte-order.
constant kMCStringEncodingUTF32BE is 8
constant kMCStringEncodingUTF16 is 9
constant kMCStringEncodingUTF32 is 10

-- MCStringEncode(*t_copy, kMCStringEncodingUTF16, false, t_encoded_paths)
__safe foreign handler MCStringEncode(in pString as String, in pEncoding as CUInt, in pIsExternalRep as CBool, out rUTF8String as Data) returns CBool binds to "<builtin>"
__safe foreign handler MCStringDecode(in pData as Data, in pEncoding as CUInt, in pIsExternalRep as CBool, out rUTF8String as String) returns CBool binds to "<builtin>"
-- bool MCStringDecode(MCDataRef data, MCStringEncoding encoding, bool is_external_rep, MCStringRef& r_string);
__safe foreign handler MCStringCreateWithCString(in pCString as Pointer, out rString as String) returns CBool binds to "<builtin>"
__safe foreign handler MCStringCreateWithWString(in pWString as Pointer, out rString as String) returns CBool binds to "<builtin>"
__safe foreign handler MCStringCreateWithSysString(in pWString as Pointer, out rString as ZStringNative) returns CBool binds to "<builtin>"
__safe foreign handler MCStringCreateWithBytes(in pBytes as Pointer, in pByteCount as LCUInt, in pEncoding as CUInt, in pIsExternalRep as CBool, out rString as String) returns CBool binds to "<builtin>"
--foreign handler MCDataConvertStringToData(in pString as String, out rData as Data) returns CBool binds to "<builtin>"
__safe foreign handler MCDataGetBytePtr(in pData as Data) returns optional Pointer binds to "<builtin>"
__safe foreign handler MCMemoryAllocate(in pSize as UIntSize, out rBlockPtr as Pointer) returns CBool binds to "<builtin>"
-- allocates a block of size pSize bytes, places the pointer into rBlockPtr and returns true - or just returns false if it fails
-- MCMemoryReallocate(T *p_block, size_t p_new_size, T*& r_new_block)
__safe foreign handler MCMemoryReallocate(in rBlockPtr as Pointer, in pSize as UIntSize, out rReAllocBlockPtr as Pointer) returns CBool binds to "<builtin>"
__safe foreign handler MCMemoryDeallocate(in rBlockPtr as Pointer) returns nothing binds to "<builtin>"
__safe foreign handler MCWidgetGetMyScriptObject(out rObject as ScriptObject) returns nothing binds to "<builtin>"
-- MCDataGetLength(t_data);

private type hid_device_infos is Pointer
private type hid_device is Pointer

private variable mDevices as optional hid_device_infos
private variable mHIDDevicesArray as Array
private variable mSelectedDevice as optional Pointer
private variable mInited as Boolean

__safe foreign handler hid_init() returns CInt binds to "c:libhidapi>hid_init"
__safe foreign handler hid_exit() returns CInt binds to "c:libhidapi>hid_exit"
__safe foreign handler hid_version_str() returns Pointer binds to "c:libhidapi>hid_version_str"
__safe foreign handler hid_enumerate(in pVendorID as CUShort, in pProductID as CUShort) returns Pointer binds to "c:libhidapi>hid_enumerate"
__safe foreign handler hid_free_enumeration(in mDevices as Pointer) returns nothing binds to "c:libhidapi>hid_free_enumeration"
__safe foreign handler hid_open(in pVendorID as CUShort, in pProductID as CUShort, in pSerial as optional ZStringUTF16) returns optional Pointer binds to "c:libhidapi>hid_open"
__safe foreign handler hid_open_path(in pSysPath as ZStringNative) returns Pointer binds to "c:libhidapi>hid_open_path"
__safe foreign handler hid_close(in pSelectedDevice as Pointer) returns nothing binds to "c:libhidapi>hid_close"
--hid_close(hid_device *dev
__safe foreign handler hid_read_timeout(in pSelectedDevice as Pointer, in rDataBufPtr as Pointer, in pMillsecs as CUInt ) returns CSInt binds to "c:libhidapi>hid_read_timeout"
-- hid_device * HID_API_CALL hid_open_path(const char *path);
-- hid_read_timeout(hid_device *dev, unsigned char *data, size_t length, int milliseconds);
-- 		HID_API_EXPORT const wchar_t* HID_API_CALL hid_error(hid_device *dev);

public handler HIDAPIInit() returns optional any
   variable tStrPtr as Pointer
   variable tString as String
   variable tResult as CInt
   variable tBool as CBool
   put hid_init() into tResult -- 0 on success and -1 on error.
   if tResult is 0 then
      put hid_version_str() into tStrPtr
      if MCStringCreateWithCString(tStrPtr, tString) then
         log ["HID API VERSION:" && tString]
         put true into mInited
      end if
   end if
   put MCMemoryAllocate(64, rBufferPtr) into tBool
end handler

-- struct hid_device_info {
--			/** Platform-specific device path */ rddrdrrddHr
--			char *path;  --  r=Pointer            element 1 = pointer to System Path String
--			/** Device Vendor ID */
--			unsigned short vendor_id; -- d=CUShort element 2
--			/** Device Product ID */
--			unsigned short product_id; -- d=CUShort element 3
--			/** Serial Number */
--			wchar_t *serial_number; -- r=Pointer     element 4
--			/** Device Release Number in binary-coded decimal, also known as Device Version Number */
--			unsigned short release_number; -- d=CUShort  element 5
--			/** Manufacturer String */
--			wchar_t *manufacturer_string; -- r=Pointer  element 6
--			/** Product string */
--			wchar_t *product_string; -- r=Pointer  element 7
--			/** Usage Page for this Device/Interface (Windows/Mac only). */
--			unsigned short usage_page; -- d=CUShort  element 8
--			/** Usage for this Device/Interface (Windows/Mac only).*/
--			unsigned short usage; d=CUShort  element 9
--			/** The USB interface which this logical device	represents.
--				* Valid on both Linux implementations in all cases.
--				* Valid on the Windows implementation only if the device contains more than one interface.
--			   * Valid on the Mac implementation if and only if the device is a USB HID device. */
--			int interface_number; -- H=CInt element 10
--			/** Pointer to the next device */
--			struct hid_device_info *next; r=Pointer  element 11  };

public foreign type HIDDevices binds to "MCAggregateTypeInfo:rddrdrrddHr" -- Declaration (numPackets: UInt32, *packet(MIDIPacket)) -- j = UInt32
public foreign type HIDDevice binds to "MCAggregateTypeInfo:rddrdrrddH" -- Declaration (numPackets: UInt32, *packet(MIDIPacket)) -- j = UInt32
public foreign type HIDByteBuffer binds to "MCAggregateTypeInfo:hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh"
__safe foreign handler PointerToHIDDevices(out rAggregate as HIDDevices, in pPointer as Pointer, in pSize as UIntSize) returns nothing binds to "c:memcpy"
__safe foreign handler PointerToHIDDevice(out rAggregate as HIDDevice, in pPointer as Pointer, in pSize as UIntSize) returns nothing binds to "c:memcpy"
__safe foreign handler PointerBufferToData(out rData as HIDByteBuffer, in pPointer as Pointer, in pSize as UIntSize) returns nothing binds to "c:memcpy"

variable rIncomingData as optional HIDByteBuffer
variable rBufferPtr as optional Pointer

public handler HIDAPIOpenAndReadFromSystemPath(in pSysPath as ZStringNative) returns optional any
   variable rBytesRead as Integer
   variable tByteCounter as Integer
   variable tReturnString as String
   variable tResult as Boolean
   -- put nothing into rIncomingData
   put nothing into mSelectedDevice
   put hid_open_path(pSysPath) into mSelectedDevice
   if mSelectedDevice is nothing then
      log "could not open path"
   else
      put hid_read_timeout(mSelectedDevice,rBufferPtr,1000) into rBytesRead
      PointerBufferToData(rIncomingData,rBufferPtr,64)
      -- log [rBytesRead,rBufferPtr,rIncomingData]
      repeat with tByteCounter from 1 up to rBytesRead
         put rIncomingData[tByteCounter] formatted as string &" " after tReturnString
      end repeat
      hid_close(mSelectedDevice)
      return tReturnString
   end if
   -- put nothing into rBufferPtr
   -- put MCMemoryDeallocate(rBufferPtr) into tResult
   -- put MCMemoryReallocate(rBufferPtr,64,rBufferPtr) into tResult
end handler

public handler HIDAPIEnumerate() returns optional any
   variable rReturnString as String
   variable tStrPtr as Pointer
   variable tString as String
   variable tSysPath as String
   variable tZStringUTF16 as ZStringUTF16
   variable tZStringNative as ZStringNative
   variable tVenderID as CUShort
   variable tProductID as CUShort
   variable rHIDDevices as HIDDevices
   variable rNextHIDDevice as HIDDevices
   variable tDevice as optional Pointer

   put the empty array into mHIDDevicesArray
   put hid_enumerate(0,0) into mDevices -- pass 0,0 (VendorID,DeviceID) to get all connected HID devices
   PointerToHIDDevices(rHIDDevices,mDevices, 1024)
   put element 1 of rHIDDevices into tStrPtr
   if MCStringCreateWithCString(tStrPtr, tSysPath) then
      put tSysPath & "\t" after rReturnString
      put the empty array into mHIDDevicesArray[tSysPath]
   end if
   put element 2 of rHIDDevices into tVenderID
   put getHexStringFromTwoByteNum(tVenderID) into tString
   put "VendorID=" & tString & "\t" after rReturnString
   put element 3 of rHIDDevices into tProductID
   put getHexStringFromTwoByteNum(tProductID) into tString
   put "ProductID=" & tString & "\t" after rReturnString
   put {"SystemPath":tSysPath,"VendorID":tVenderID,"ProductID":tProductID} into mHIDDevicesArray[tSysPath]
   put element 6 of rHIDDevices into tStrPtr
      if MCStringCreateWithBytes(tStrPtr,64,kMCStringEncodingUTF8,false,tString) then
      put "Manufacturer=" & tString & "\t" after rReturnString
   end if
   put element 7 of rHIDDevices into tStrPtr
   if MCStringCreateWithBytes(tStrPtr,64,kMCStringEncodingUTF8,false,tString) then
      put "Product=" & tString & "\t" after rReturnString
   end if
   put nothing into tDevice
   put element 11 of rHIDDevices into tDevice
   repeat forever
      if tDevice is nothing then
         exit repeat /* iterator */
      end if
      put "\n" after rReturnString
      -- log ["Next Dev Pointer=", tDevice]
      PointerToHIDDevices(rNextHIDDevice, tDevice, 1024)
      put element 1 of rNextHIDDevice into tStrPtr
      if MCStringCreateWithCString(tStrPtr, tSysPath) then
         put "PATH=" && tSysPath & "\t" after rReturnString
         put the empty array into mHIDDevicesArray[tSysPath]
      end if
      put element 2 of rNextHIDDevice into tVenderID
      put getHexStringFromTwoByteNum(tVenderID) into tString
      put "VendorID=" & tString & "\t" after rReturnString
      put element 3 of rNextHIDDevice into tProductID
      put getHexStringFromTwoByteNum(tProductID) into tString
      put "ProductID=" & tString & "\t" after rReturnString
      put {"SystemPath":tSysPath,"VendorID":tVenderID,"ProductID":tProductID} into mHIDDevicesArray[tSysPath]
      put element 6 of rNextHIDDevice into tStrPtr
      -- if MCStringCreateWithWString(tStrPtr, tZStringUTF16) then
      if MCStringCreateWithBytes(tStrPtr,64,kMCStringEncodingUTF8,false,tString) then
         put "Manufacturer=" & tString & "\t" after rReturnString
      end if
      put element 7 of rNextHIDDevice into tStrPtr
      if MCStringCreateWithBytes(tStrPtr,64,kMCStringEncodingUTF8,false,tString) then -- kMCStringEncodingUTF16
         put "Product=" & tString & "\t" after rReturnString
      end if
      put nothing into tDevice
      put element 11 of rNextHIDDevice into tDevice
      -- log ["Next Dev Pointer=", tDevice]
      if (tDevice is nothing) then
         exit repeat
      else
         next repeat
      end if
   end repeat
   hid_free_enumeration(mDevices)
   return rReturnString
end handler

public handler getHexStringFromTwoByteNum( in pTwoByteNum as Number) returns optional String
   variable tNum as Number
   variable tBinsStr as String
   put pTwoByteNum converted to base 16 into tBinsStr
   if (the number of chars in tBinsStr) < 4 then
      put 4 - (the number of chars in tBinsStr) into tNum
      repeat tNum times
         put "0" before tBinsStr
      end repeat
   end if
   return tBinsStr
end handler

end library
