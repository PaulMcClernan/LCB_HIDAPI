library community.livecode.paulmcclernan.hidapi

metadata version is "0.2"
metadata author is "Paul McClernan"
metadata title is "LC HID API"

use com.livecode.foreign
use com.livecode.canvas
use com.livecode.string
use com.livecode.char
use com.livecode.array
use com.livecode.list
use com.livecode.widget
use com.livecode.engine
use com.livecode.library.widgetutils
use com.livecode.system
use com.livecode.byte
use com.livecode.date
use com.livecode.binary
use com.livecode.bitwise
use com.livecode.math

-- MCStringEncodings
constant kMCStringEncodingASCII is 0 -- The (7-bit) ASCII encoding.
constant	kMCStringEncodingWindows1252 is 1 -- The standard Windows (Latin-1) encoding.
constant	kMCStringEncodingMacRoman is 2 -- The standard Mac (Latin-1) encoding.
constant kMCStringEncodingISO8859_1 is 3 -- The standard Linux (Latin-1) encoding.
constant kMCStringEncodingUTF8 is 4 -- The UTF-8 string encoding.  In LiveCode, this permits overlong sequences when decoding, but does not generate them when encoding.
constant	kMCStringEncodingUTF16LE is 5 -- The UTF-16 string encoding in little endian byte-order.
constant kMCStringEncodingUTF16BE is 6 -- The UTF-16 string encoding in big endian byte-order.
constant kMCStringEncodingUTF32LE is 7 -- The UTF-32 string encoding in little endian byte-order.
constant kMCStringEncodingUTF32BE is 8 -- The UTF-32 string encoding in big endian byte-order.
constant kMCStringEncodingUTF16 is 9
constant kMCStringEncodingUTF32 is 10

-- MCStringEncode(*t_copy, kMCStringEncodingUTF16, false, t_encoded_paths)
__safe foreign handler MCStringEncode(in pString as String, in pEncoding as CUInt, in pIsExternalRep as CBool, out rUTF8String as Data) returns CBool binds to "<builtin>"
__safe foreign handler MCStringDecode(in pData as Data, in pEncoding as CUInt, in pIsExternalRep as CBool, out rUTF8String as String) returns CBool binds to "<builtin>"
-- bool MCStringDecode(MCDataRef data, MCStringEncoding encoding, bool is_external_rep, MCStringRef& r_string);
__safe foreign handler MCStringCreateWithCString(in pCString as Pointer, out rString as String) returns CBool binds to "<builtin>"
__safe foreign handler MCStringCreateWithWString(in pWString as Pointer, out rString as ZStringUTF16) returns CBool binds to "<builtin>"
__safe foreign handler MCStringCreateWithSysString(in pWString as Pointer, out rString as ZStringNative) returns CBool binds to "<builtin>"
__safe foreign handler MCStringCreateWithBytes(in pBytes as Pointer, in pByteCount as LCUInt, in pEncoding as CUInt, in pIsExternalRep as CBool, out rString as String) returns CBool binds to "<builtin>"
--foreign handler MCDataConvertStringToData(in pString as String, out rData as Data) returns CBool binds to "<builtin>"
__safe foreign handler MCDataGetBytePtr(in pData as Data) returns optional Pointer binds to "<builtin>"
__safe foreign handler MCMemoryAllocate(in pSize as UIntSize, out rBlockPtr as Pointer) returns CBool binds to "<builtin>"
-- allocates a block of size pSize bytes, places the pointer into rBlockPtr and returns true - or just returns false if it fails
-- MCMemoryReallocate(T *p_block, size_t p_new_size, T*& r_new_block)
__safe foreign handler MCMemoryReallocate(in rBlockPtr as Pointer, in pSize as UIntSize, out rReAllocBlockPtr as Pointer) returns CBool binds to "<builtin>"
__safe foreign handler MCMemoryDeallocate(in rBlockPtr as Pointer) returns nothing binds to "<builtin>"
__safe foreign handler MCWidgetGetMyScriptObject(out rObject as ScriptObject) returns nothing binds to "<builtin>"
-- MCDataGetLength(t_data);

private type hid_device_infos is Pointer
private type hid_device is Pointer
public foreign type HIDDevices binds to "MCAggregateTypeInfo:rddrdrrddHr"
public foreign type HIDByteBuffer binds to "MCAggregateTypeInfo:hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh"
__safe foreign handler PointerToHIDDevices(out rAggregate as HIDDevices, in pPointer as Pointer, in pSize as UIntSize) returns nothing binds to "c:memcpy"
__safe foreign handler PointerBufferToData(out rData as HIDByteBuffer, in pPointer as Pointer, in pSize as UIntSize) returns nothing binds to "c:memcpy"

private variable mDevices as optional hid_device_infos
private variable mHIDDevicesArray as Array
private variable mSelectedDevice as optional Pointer
private variable mInited as Boolean
variable rIncomingData as optional HIDByteBuffer
variable rBufferPtr as optional Pointer

__safe foreign handler hid_init() returns CInt binds to "c:libhidapi>hid_init"
__safe foreign handler hid_exit() returns CInt binds to "c:libhidapi>hid_exit"
__safe foreign handler hid_version_str() returns Pointer binds to "c:libhidapi>hid_version_str"
__safe foreign handler hid_enumerate(in pVendorID as CUShort, in pProductID as CUShort) returns Pointer binds to "c:libhidapi>hid_enumerate"
__safe foreign handler hid_free_enumeration(in mDevices as Pointer) returns nothing binds to "c:libhidapi>hid_free_enumeration"
__safe foreign handler hid_open(in pVendorID as CUShort, in pProductID as CUShort, in pSerial as optional ZStringUTF16) returns optional Pointer binds to "c:libhidapi>hid_open"
__safe foreign handler hid_open_path(in pSysPath as ZStringNative) returns Pointer binds to "c:libhidapi>hid_open_path"
__safe foreign handler hid_close(in pSelectedDevice as Pointer) returns nothing binds to "c:libhidapi>hid_close"
__safe foreign handler hid_read_timeout(in pSelectedDevice as Pointer, in rDataBufPtr as Pointer,in pBytesToRead as UIntSize, in pMillsecs as CUInt ) returns CSInt binds to "c:libhidapi>hid_read_timeout"
__safe foreign handler hid_read(in pSelectedDevice as Pointer, in rDataBufPtr as Pointer,in pBytesToRead as UIntSize) returns CSInt binds to "c:libhidapi>hid_read"
__safe foreign handler hid_set_nonblocking(in pSelectedDevice as Pointer, in pBlocking as CUInt) returns CSInt binds to "c:libhidapi>hid_set_nonblocking"
__safe foreign handler hid_error(in pSelectedDevice as Pointer) returns Pointer binds to "c:libhidapi>hid_error"
-- 		HID_API_EXPORT const wchar_t* HID_API_CALL hid_error(hid_device *dev);

public handler HIDAPIInit() returns optional any
   variable tStrPtr as Pointer
   variable tString as String
   variable tResult as CInt
   variable tBool as CBool
   put MCMemoryAllocate(1024, rBufferPtr) into tBool
   put hid_init() into tResult -- 0 on success and -1 on error.
   if tResult is 0 then
      put hid_version_str() into tStrPtr
      if MCStringCreateWithCString(tStrPtr, tString) then
         put true into mInited
         -- log ["HID API VERSION:" && tString]
         return "HID API VERSION:" && tString
      end if
   else
      return "error initializing HID API" && tString
   end if
end handler
public handler HIDAPIExit() returns optional any
   variable tResult as CSInt
   if mInited then
      if mSelectedDevice is not nothing then
         hid_close(mSelectedDevice)
         put nothing into mSelectedDevice
      end if
      put hid_exit() into tResult -- 0 on success and -1 on error.
      if tResult is -1 then
         return "error exiting HID API"
      else
         MCMemoryDeallocate(rBufferPtr)
         put nothing into rBufferPtr
         put nothing into rIncomingData
         put false into mInited
         return "HID API exited"
      end if
   else
      return "HID API was not initialized"
   end if
end handler

public handler HIDAPISetBlockingMode(in pBlocking as Boolean) returns optional any
   --  hid_set_nonblocking(hid_device *dev, int 1 to enable nonblocking or 0 to disable nonblocking.) returns 0 on success and -1 on error.
   if mSelectedDevice is not nothing then
      if pBlocking then -- blocking set to true
         if hid_set_nonblocking(mSelectedDevice,0) is not -1 then
            return
         else
            return "error setting blocking mode"
         end if
      else -- blocking set to false
         if hid_set_nonblocking(mSelectedDevice,1) is not -1 then
            return
         else
            return "error setting blocking mode"
         end if
      end if
   end if
end handler
public handler HIDAPIOpenFromSystemPath(in pSysPath as ZStringNative) returns optional any
   -- variable tPointerAsNum as UIntSize
   if mSelectedDevice is nothing then
      put hid_open_path(pSysPath) into mSelectedDevice
      if mSelectedDevice is nothing then
         return "error opening path to device"
      else
         return "device access opened" -- mSelectedDevice
      end if
   end if
end handler

public handler HIDAPIClose() returns optional any
   if mSelectedDevice is not nothing then
      hid_close(mSelectedDevice)
      put nothing into mSelectedDevice
   else

   end if
end handler

public handler HIDAPIRead() returns optional any
   if mSelectedDevice is not nothing then
      variable rBytesRead as Integer
      variable tByteCounter as Integer
      variable tWCharStrPtr as Pointer
      variable tString as String
      variable tReturnString as String
      variable tResult as Boolean
      put nothing into rIncomingData
      if mSelectedDevice is nothing then
         return "error opening path to device"
      else
         put hid_read(mSelectedDevice,rBufferPtr,64) into rBytesRead
         if rBytesRead is -1 then
            return "error reading from device" -- && tReturnString
         else
            PointerBufferToData(rIncomingData,rBufferPtr,64)
            -- log [rBytesRead,rBufferPtr,rIncomingData]
            repeat with tByteCounter from 1 up to rBytesRead
               put rIncomingData[tByteCounter] formatted as string &" " after tReturnString
            end repeat
            return tReturnString
         end if
      end if
   else
      return "error no open device to read from"
   end if
 end handler

public handler HIDAPIOpenAndReadFromSystemPath(in pSysPath as ZStringNative, in pWaitMillisecs as optional Number) returns optional any
   variable rBytesRead as Integer
   variable tByteCounter as Integer
   variable tWCharStrPtr as Pointer
   variable tString as String

   variable tReturnString as String
   variable tResult as Boolean
   put nothing into rIncomingData
   put nothing into mSelectedDevice
   if pWaitMillisecs is nothing then
      put 250 into pWaitMillisecs
   end if
   put hid_open_path(pSysPath) into mSelectedDevice
   if mSelectedDevice is nothing then
      return "error opening path to device"
   else
      put hid_read_timeout(mSelectedDevice,rBufferPtr,64,pWaitMillisecs) into rBytesRead
      if rBytesRead is -1 then
         -- put hid_error(mSelectedDevice) into tWCharStrPtr -- disabled because the only error message is "hid_error not implemented yet"
         -- if MCStringCreateWithBytes(tWCharStrPtr,256,kMCStringEncodingUTF8,false,tString) then
         --    put char 1 to (getWCharStringSizeOf(tWCharStrPtr)) of tString into tReturnString
         -- end if
         hid_close(mSelectedDevice)
         return "error reading from device" -- && tReturnString
      else
         hid_close(mSelectedDevice)
         PointerBufferToData(rIncomingData,rBufferPtr,64)
         -- log [rBytesRead,rBufferPtr,rIncomingData]
         repeat with tByteCounter from 1 up to rBytesRead
            put rIncomingData[tByteCounter] formatted as string &" " after tReturnString
         end repeat
         return tReturnString
      end if
   end if
   -- put nothing into rBufferPtr
   -- put MCMemoryDeallocate(rBufferPtr) into tResult
   -- put MCMemoryReallocate(rBufferPtr,64,rBufferPtr) into tResult
end handler

public handler HIDAPIEnumerate() returns optional any
   variable rReturnString as String
   variable tStrPtr as Pointer
   variable tString as String
   variable tSysPath as String
   variable tZStringUTF16 as ZStringUTF16
   variable tZStringNative as ZStringNative
   variable tVenderID as CUShort
   variable tProductID as CUShort
   variable rHIDDevices as HIDDevices
   variable rNextHIDDevice as HIDDevices
   variable tDevice as optional Pointer
   variable tStatus as Boolean
   variable tNum as Number
   variable rData as optional HIDByteBuffer
   put nothing into mDevices
   put the empty array into mHIDDevicesArray
   -- put "DEVICE PATH\t"&"VendorID(hex)\t"&"ProductID(hex)\t"&"Manufacturer\t"&"Product\t"&"UsagePage\t"&"Usage\n" into rReturnString
   put the empty string into rReturnString
   put hid_enumerate(0,0) into mDevices -- pass 0,0 (VendorID,DeviceID) to get all connected HID devices
   PointerToHIDDevices(rHIDDevices,mDevices, 1024)
   put element 1 of rHIDDevices into tStrPtr
   if MCStringCreateWithCString(tStrPtr, tSysPath) then
      put tSysPath & "\t" after rReturnString
      -- put the empty array into mHIDDevicesArray[tSysPath]
   else
      put "\t" after rReturnString
   end if
   put element 2 of rHIDDevices into tVenderID
   put getHexStringFromTwoByteNum(tVenderID) into tString
   put tString & "\t" after rReturnString
   put element 3 of rHIDDevices into tProductID
   put getHexStringFromTwoByteNum(tProductID) into tString
   put tString & "\t" after rReturnString
   -- put {"SystemPath":tSysPath,"VendorID":tVenderID,"ProductID":tProductID} into mHIDDevicesArray[tSysPath]
   put element 6 of rHIDDevices into tStrPtr
   if MCStringCreateWithBytes(tStrPtr,256,kMCStringEncodingUTF8,false,tString) then
      put char 1 to (getWCharStringSizeOf(tStrPtr)) of tString & "\t" after rReturnString
   else
       put "\t" after rReturnString
   end if
   put element 7 of rHIDDevices into tStrPtr
   if MCStringCreateWithBytes(tStrPtr,256,kMCStringEncodingUTF8,false,tString) then
      put char 1 to (getWCharStringSizeOf(tStrPtr)) of tString & "\t" after rReturnString
   else
      put "\t" after rReturnString
   end if
   put "" into tString
   put HIDUsagePageNumToString(element 8 of rHIDDevices) into tString
   put tString & "\t" after rReturnString
   put "" into tString
   if element 8 of rHIDDevices = 1 then
      put HIDGenericDesktopUsageNumToString(element 9 of rHIDDevices) into tString
   else
      put element 9 of rHIDDevices formatted as string into tString
   end if
   put tString & "\t" after rReturnString
   put "" into tString

   put nothing into tDevice
   put element 11 of rHIDDevices into tDevice
    if tDevice is nothing then
      hid_free_enumeration(mDevices)
      return rReturnString
   end if

   repeat forever
      if tDevice is nothing then
         exit repeat
      else
         put "\n" after rReturnString
      end if
      -- log ["Next Dev Pointer=", tDevice]
      PointerToHIDDevices(rNextHIDDevice, tDevice, 1024)
      put element 1 of rNextHIDDevice into tStrPtr
      if MCStringCreateWithCString(tStrPtr, tSysPath) then
         put tSysPath & "\t" after rReturnString
         -- put the empty array into mHIDDevicesArray[tSysPath]
      end if
      put element 2 of rNextHIDDevice into tVenderID
      put getHexStringFromTwoByteNum(tVenderID) into tString
      put tString & "\t" after rReturnString -- "VendorID"
      put element 3 of rNextHIDDevice into tProductID
      put getHexStringFromTwoByteNum(tProductID) into tString
      put tString & "\t" after rReturnString -- "ProductID=""
      -- put {"SystemPath":tSysPath,"VendorID":tVenderID,"ProductID":tProductID} into mHIDDevicesArray[tSysPath]
      put element 6 of rNextHIDDevice into tStrPtr
      --put MCStringCreateWithWString(tStrPtr,tZStringUTF16) into tStatus -- Doesn't work as expected
      if MCStringCreateWithBytes(tStrPtr,256,kMCStringEncodingUTF8,false,tString) then
         put char 1 to (getWCharStringSizeOf(tStrPtr)) of tString & "\t" after rReturnString -- "Manufacturer"
      else
          put "\t" after rReturnString
      end if
      put element 7 of rNextHIDDevice into tStrPtr
      if MCStringCreateWithBytes(tStrPtr,256,kMCStringEncodingUTF8,false,tString) then -- kMCStringEncodingUTF16
         put char 1 to (getWCharStringSizeOf(tStrPtr)) of tString & "\t" after rReturnString -- "Product"
      else
          put "\t" after rReturnString
      end if
      put "" into tString
      put HIDUsagePageNumToString(element 8 of rNextHIDDevice) into tString
      put tString & "\t" after rReturnString -- "UsagePage"
      put "" into tString
      if element 8 of rNextHIDDevice = 1 then
         put HIDGenericDesktopUsageNumToString(element 9 of rNextHIDDevice) into tString
      else
         put element 9 of rNextHIDDevice formatted as string into tString
      end if
      put tString & "\t" after rReturnString -- "Usage"
      put "" into tString

      put nothing into tDevice
      put element 11 of rNextHIDDevice into tDevice
      -- log ["Next Dev Pointer=", tDevice]
      if (tDevice is nothing) then
         exit repeat
      else
         next repeat
      end if
   end repeat
   hid_free_enumeration(mDevices)
   return rReturnString
end handler

public handler getWCharStringSizeOf(in pPointer as Pointer) returns optional Number
   variable rData as HIDByteBuffer
   variable tNum as Number
   PointerBufferToData(rData,pPointer,256)
   repeat with tNum from 1 up to 252
      if element tNum of rData is 0 and element tNum+1 of rData is 0 and element tNum+2 of rData is 0 and element tNum+3 of rData is 0 then -- find *wchar_t null termination?
         return tNum
         exit repeat
      end if
   end repeat
   return -1
end handler

public handler getHexStringFromTwoByteNum( in pTwoByteNum as Number) returns optional String
   variable tNum as Number
   variable tBinsStr as String
   put pTwoByteNum converted to base 16 into tBinsStr
   if (the number of chars in tBinsStr) < 4 then
      put 4 - (the number of chars in tBinsStr) into tNum
      repeat tNum times
         put "0" before tBinsStr
      end repeat
   end if
   return tBinsStr
end handler

public handler HIDGenericDesktopUsageNumToString(in pUsagePageNumber as Number) returns String
   if pUsagePageNumber < 19 then
      variable tUsagePageList as List
      put ["0 Undefined","1 Pointer","2 Mouse","3 Reserved","4 Joystick","5 Gamepad","6 Keyboard","7 Keypad","8 Multi-axis_Control","9 Tablet_Control","10 Water_Cooling","11 Chassis_Device","12 Radio_Controls","13 Portable_Device","14 System_Multi-axis","15 Spatial_Control","16 Assistive_Control","17 Device_Dock","18 Dockable_Device"] into tUsagePageList
      return element (pUsagePageNumber +1) of tUsagePageList
   end if
   return pUsagePageNumber formatted as string
end handler

public handler HIDUsagePageNumToString(in pUsagePageNumber as Number) returns String
   if pUsagePageNumber < 21 then
      variable tUsagePageList as List
      put ["0 Undefined","1 Generic_Desktop","2 Simulation","3 VR","4 Sport","5 Game","6 Generic_Controls","7 Keyboard_Keypad","8 LEDs","9 Button","10 Ordinal","11 Telephony","12 Consumer","13 Digitizer_TouchScreen","14 Haptics","15 Physical Force Device","16 Unicode","17 Reserved","18 Eye_Head_Trackers","19 Reserved","20 Aux_Display"] into tUsagePageList
      return element (pUsagePageNumber +1) of tUsagePageList
   else
      --kHIDPage_PID is 15	/* force feedback and related devices. */
      if pUsagePageNumber > 20 and pUsagePageNumber < 32 then
         return pUsagePageNumber formatted as string && "Reserved"
      end if
      if pUsagePageNumber = 32 then
         return "32 Sensors"
      end if
      if pUsagePageNumber > 32 and pUsagePageNumber < 64 then
         return pUsagePageNumber formatted as string && "Reserved"
      end if
      if pUsagePageNumber = 64 then
         return "32 Medical_Instrument"
      end if
      if pUsagePageNumber = 65 then
         return "65 Braille_Display"
      end if
      if pUsagePageNumber > 65 and pUsagePageNumber < 89 then
         return pUsagePageNumber formatted as string && "Reserved"
      end if
      if pUsagePageNumber = 89 then
         return "89 Lighting"
      end if
      if pUsagePageNumber > 89 and pUsagePageNumber < 128 then
         return pUsagePageNumber formatted as string && "Reserved"
      end if
      if pUsagePageNumber > 127 and pUsagePageNumber < 132 then
         return pUsagePageNumber formatted as string && "Monitor"
      end if
      if pUsagePageNumber = 132 or pUsagePageNumber = 134 or pUsagePageNumber = 135 then
         return pUsagePageNumber formatted as string && "Power_Device"
      end if
      if pUsagePageNumber = 133 then
         return "133 Battery_System"
      end if
      if pUsagePageNumber > 135 and pUsagePageNumber < 140 then
         return pUsagePageNumber formatted as string && "Reserved"
      end if
      if pUsagePageNumber > 139 and pUsagePageNumber < 147 then
         variable tUsagePageList as List
         put ["140 Barcode_Scanner","141 Weighing_Device","142 Magnetic_Strip_Reader","143 Point_of_Sale Reserved","144 Camera_Control","145 OAAF_Arcade_CoinOp","146 GSA_Gaming"] into tUsagePageList
         return element (pUsagePageNumber - 139) of tUsagePageList
      end if
      if pUsagePageNumber = 61904 then
         return "61904 FIDO_Alliance" -- FIDO = Fast ID Online
      end if
      if (pUsagePageNumber > 146 and pUsagePageNumber < 61904) or (pUsagePageNumber > 61904 and pUsagePageNumber < 65280) then
         return pUsagePageNumber formatted as string && "Reserved"
      end if
      if pUsagePageNumber > 65279 then
         return pUsagePageNumber formatted as string && "Vendor_Defined"
      end if
   end if
end handler

end library

-- struct hid_device_info {
--			/** Platform-specific device path */ rddrdrrddHr
--			char *path;  --  r=Pointer            element 1 = pointer to System Path String
--			/** Device Vendor ID */
--			unsigned short vendor_id; -- d=CUShort element 2
--			/** Device Product ID */
--			unsigned short product_id; -- d=CUShort element 3
--			/** Serial Number */
--			wchar_t *serial_number; -- r=Pointer     element 4
--			/** Device Release Number in binary-coded decimal, also known as Device Version Number */
--			unsigned short release_number; -- d=CUShort  element 5
--			/** Manufacturer String */
--			wchar_t *manufacturer_string; -- r=Pointer  element 6
--			/** Product string */
--			wchar_t *product_string; -- r=Pointer  element 7
--			/** Usage Page for this Device/Interface (Windows/Mac only). */
--			unsigned short usage_page; -- d=CUShort  element 8
--			/** Usage for this Device/Interface (Windows/Mac only).*/
--			unsigned short usage; d=CUShort  element 9
--			/** The USB interface which this logical device	represents.
--				* Valid on both Linux implementations in all cases.
--				* Valid on the Windows implementation only if the device contains more than one interface.
--			   * Valid on the Mac implementation if and only if the device is a USB HID device. */
--			int interface_number; -- H=CInt element 10
--			/** Pointer to the next device */
--			struct hid_device_info *next; r=Pointer  element 11  };
